### A Nbdev script file ###
### Autogenerated file. Don't modify. ###

module Readnb
#export
include("Nb.jl")

#export
begin
    Code =Nb.Code
    Mk = Nb.Mk
    Cell = Nb.Cell
    Notebook = Nb.Notebook
end

#export
CodeOrMk = Union{Nb.Code, Nb.Mk}

#export
"""
> getcellwithtype(cell::String)::CodeOrMk--> Cast cell into respective types
"""
function getcellwithtype(cell::String)::CodeOrMk
	if startswith(cell, "md")
		cell = Mk(cell)
	elseif startswith(cell, "#export")
		cell = Code(cell, true, false, false, false)
	elseif startswith(cell, "#hide")
		cell = Code(cell, false, true, false, false)
	elseif startswith(cell, "#noop")
		cell = Code(cell, false, false, true, false)
	else
		cell = Code(cell, false, false, false, true)
	end

	return cell

end

#export
"""
This had to be done because having the cell iddelimeter as a constant gives an error during parsing the notebook
"""
celliddelim=string("#"," ╔═╡ ")

#export
"""
marks the end of a cell
"""
const cellsuff = "\n\n"

#export
"""
> collectcells(io)--> Collect cells of a notebook
"""
function collectcells(io)
    collectedcells = []
		
	# ignore first bits of file
    readuntil(io,celliddelim)

    last_read = ""
    while !eof(io)
        cellidstr = String(readline(io))
        if cellidstr == "Cell order:" || cellidstr == "00000000-0000-0000-0000-000000000001"
            break
        else
            rawcell = String(readuntil(io, celliddelim))
            # change Windows line endings to Linux
            normalisedcell = replace(rawcell, "\r\n" => "\n")
            # remove the cell appendix
            cell = normalisedcell[1:prevind(normalisedcell, end, length(cellsuff))]
			cell = Cell(getcellwithtype(cell))
            push!(collectedcells, cell)
        end
    end
		
	return collectedcells
end

#export
"""
>readnb(path::String)::Notebook--> read a notebook and return an array of cells
"""	
function readnb(path::String)::Notebook
        cells = []
        open(path, "r") do io
            cells = collectcells(io)
        end
        Notebook(cells, basename(path))
end
end